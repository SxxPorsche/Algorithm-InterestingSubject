缓存控制策略就是 http caching 的策略，化繁为简，最有效的策略往往是很简单的。
在最简单的粗略下，你对 http cache 只需要了解一个 Cache-Control 的头部。
一个较好的缓存策略只需要两部分，而它们只需要通过 Cache-Control 控制：

带hash资源: 永久缓存
非带hash资源: 每次进行新鲜度校验


#### 1. 带hash资源: 永久缓存
```
Cache-Control: max-age=31536000
```
天下武功，无坚不摧，唯快不破。资源请求最快的方式就是不向服务器发起请求，通过以上响应头可以对资源设置永久缓存。

1. 静态资源带有 hash 值，即指纹
2. 对资源设置一年过期时间，即 31536000，一般认为是永久缓存
3. 在永久缓存期间浏览器不需要向服务器发送请求

那为什么带有 hash 值的资源可以永久缓存呢？
因为该文件的内容发生变化时，会生成一个带有新的 hash 值的 URL。 前端将会发起一个新的 URL 的请求。


#### 2. 非带hash资源: 每次进行新鲜度校验， 即协商缓存
```
Cache-Control: no-cache
```
1. 由于不带有hash，每次都需要校验资源是否最新。(从缓存中取到资源，可能是过期资源)
2. 如果校验为最新资源，则从浏览器的缓存中加载资源

如果浏览器/CDN上缓存经校验没有过期。这被称为协商缓存，此时 http 状态码返回 304，指 Not Modified。
关于协商缓存，你无需管理，也无需配置， nginx 或者一些 OSS 都会自动配置协商缓存。
而对于协商缓存，也有它们自己的算法，协商缓存的背后基于响应头 Last-Modified/ETag。
浏览器每次请求资源时，会携带上次服务器响应的 ETag/Last-Modified 作为标志，与服务端此时的 ETag/Last-Modified 作比较，来判断内容更改。

而在操作系统底层，Last-Modified 往往通过文件系统(file system)中的 mtime 属性生成。
而 ETag 提供比 Last-Modified 更精细的检验粒度，由文件内容的 hash 或者 mtime/size 生成。


#### 3. 为资源添加 Cache-Control 响应头

##### 3.1 那如果不添加 Cache-Control 这个响应头会怎么样？
是不是每次都会自动去服务器校验新鲜度，很可惜，不是。 
此时会对资源进行强制缓存，而对不带有 hash 信息的资源很有可能获取到过期资源。 
如果过期资源存在于浏览器上，还可以通过强制刷新浏览器来获取最新资源。
但是如果过期资源存在于 CDN 的边缘节点上，CDN 的刷新就会复杂很多，而且有可能需要多人协作解决。

##### 3.2 那默认的强制缓存时间是多少
首先要明确两个响应头代表的含义：

Date: 指源服务器响应报文生成的时间，差不多与发请求的时间等价
Last-Modified: 指静态资源上次修改的时间，取决于 mtime

LM factor 算法认为当请求服务器时，如果没有设置 Cache-Control，如果距离上次的 Last-Modified 越远，则生成的强制缓存时间越长。
用公式表示如下，其中 factor 介于 0 与 1 之间：
```
MaxAge = (Date - LastModified) * factor
```

#### 4. Bundle Splitting：尽量减少资源变更, 分层次缓存打包

1. webpack-runtime: 应用中的 webpack 的版本比较稳定，分离出来，保证长久的永久缓存
2. react/react-dom: react 的版本更新频次也较低
3. vendor: 常用的第三方模块打包在一起，如 lodash，classnames 基本上每个页面都会引用到，但是它们的更新频率会更高一些。
4. 另外对低频次使用的第三方模块不要打进来， 不常用且过大的第三方模块单独打包

随着 http2 的发展，特别是多路复用，初始页面的静态资源不受资源数量的影响。
因此为了更好的缓存效果以及按需加载，也有很多方案建议把所有的第三方模块进行单模块打包。

