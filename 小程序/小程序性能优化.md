### 1. 启动加载性能优化
#### 启动过程机制
* 资源准备（代码下载）
* 业务代码注入和渲染
* 异步请求数据（部分小程序）

#### 控制代码包的大小
* 开启开发者工具中的“上传代码时候自动压缩”
* 及时清除无用代码和资源文件
* 减少代码包中的图片等资源文件的大小和数量，如使用CDN

#### 分包加载
分包加载的局限性和解决方法

* 分包预加载（即将推出的功能）
* 分包加载——独立分包（即将推出）
  - 可以不依赖于主包，独立下载和运行的分包
  - 从独立分包页面启动，只下载和注入分包就可以打开页面

#### 首屏加载的体验优化建议

* 提前请求：异步请求数据不需要等待页面的渲染完成（onLoad阶段请求）
* 利用缓存
  - 利用storage API对异步请求数据进行缓存。
  - 二次启动的时候，先利用缓存数据渲染页面，再进行后台更新
* 避免白屏：先展示页面骨架和基础内容
* 及时反馈, 再请求。 (如：点赞的按钮，可以先改变按钮的样式，再发起异步请求)

### 2. 渲染机制的优化
#### 避免不当使用setData
setData原理：
* 每次setData的调用都是一次进程间的通信过程，通信开销与setData的数据量正相关的
    每调用一次setData, 都是逻辑层通过native层，再传给webview渲染层。
    
* setData会引发视图层页面内容的更新，这一耗时操作一定时间内会阻塞用户交互
    渲染层收到通讯后，还需要重新渲染出来。
    
* setData是小程序中使用最频繁，也是最容易引发性能问题的
    一次setData带来两次开销：通信的开销 + webview更新的开销

优化setData：
* 不要使用data在方法间共享数据（可能增加setData传输的数据量）  
    ——建议data中仅包括与页面相关的数据
* 不要使用setData传输大量数据  
    ——仅仅传输变化的数据，减少setData数据量
* 不要短时间频繁调用setData  
    ——对连续的setData进行合并
* 不要在后台页面进行setData，抢占前台页面的渲染资源  
    ——页面在切入后台后的setData调用，延迟到页面重新展示的时候执行

#### 避免不当使用onPageScroll     
* 只在有必要的时候监听pageScroll事件
* 避免在onPageScroll中执行复杂逻辑
* 避免在onPageScroll中频繁调用setData
* 避免频繁查询节点信息（SelectQuery)
  ——部分场景建议使用节点布局相交状态监听（IntersectionObserver）替代
