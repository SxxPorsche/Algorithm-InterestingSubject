## HTTP/1.1 存在问题：
### 1、TCP 连接数限制
对于同一个域名，浏览器最多只能同时创建 6~8 个 TCP 连接
为了尽可能减少请求数，需要做合并文件、雪碧图、资源内联等优化工作，
但是这无疑造成了单个请求内容变大延迟变高的问题，且内嵌的资源不能有效地使用缓存机制

### 2、线头阻塞 (Head Of Line Blocking) 问题
每个 TCP 连接同时只能处理一个请求 - 响应，浏览器按 FIFO 原则处理请求，如果上一个响应没返回，后续请求 - 响应都会受阻

### 3、Header 内容多，而且每次请求 Header 不会变化太多，没有相应的压缩传输优化方案

### 4、明文传输不安全

## HTTP2的优势
### 1、二进制分帧层 (Binary Framing Layer)
帧是数据传输的最小单位，以二进制传输代替原本的明文传输，原本的报文消息被划分为更小的数据帧

### 2、多路复用 (MultiPlexing)
在一个 TCP 连接上，我们可以向对方不断发送帧，每帧的 stream identifier 的标明这一帧属于哪个流，然后在对方接收时，根据 stream identifier 拼接每个流的所有帧组成一整块数据
所以 http2 对于同一域名只需要创建一个连接

### 3、服务端推送 (Server Push)
浏览器发送一个请求，服务器主动向浏览器推送与这个请求相关的资源，这样浏览器就不用发起后续请求。

Server-Push 主要是针对资源内联做出的优化，相较于 http/1.1 资源内联的优势:
* 客户端可以缓存推送的资源
* 客户端可以拒收推送过来的资源
* 推送资源可以由不同页面共享
* 服务器可以按照优先级推送资源

### 4、Header 压缩 (HPACK)
使用 HPACK 算法来压缩首部内容

### 5、应用层的重置连接
HTTP/2 引入 RST_STREAM 类型的 frame，可以在不断开连接的前提下取消某个 request 的 stream

### 6、请求优先级设置
HTTP/2 里的每个 stream 都可以设置依赖 (Dependency) 和权重，可以按依赖树分配优先级，解决了关键请求被阻塞的问题

### 7、流量控制
每个 http2 流都拥有自己的公示的流量窗口，它可以限制另一端发送数据
